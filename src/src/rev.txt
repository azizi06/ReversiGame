#include"reversi.h"
#include "map.h"
#include <stdlib.h>
#include <stdio.h>
#include <tools.h>
struct Reversi* new_reversi();
struct MSet* avaible_actions(int game_matrix[ROWS][COLUMNS],int player);
void perform_move(struct Reversi *self,struct Move* move);
bool isgame_over(struct Reversi *self);
void next_player(struct Reversi *self);
void count_score(struct Reversi *self);
void print_game(struct Reversi *self);
bool is_valid_move(int board[ROWS][COLUMNS], int row, int col, int player);
struct MSet* find_possible_moves(int board[ROWS][COLUMNS], int player, int possible_moves[ROWS * COLUMNS][2], int* num_moves);


struct Reversi* new_reversi(){
    struct Reversi* r = (struct Reversi*) malloc(sizeof(struct Reversi));
    r->player = B;
    r->winner = None;
    r->score_b = 2;
    r->score_w =2;
    r->move = &perform_move;
    r->next = &next_player;
    r->isgame_over = &isgame_over;
    r->print = &print_game;
    r->count = &count_score;

    r->game_matrix[3][3]= W;
    r->game_matrix[3][4]= B;
    r->game_matrix[4][3]= B;
    r->game_matrix[4][4]= W;

    return r;
}
struct MSet* avaible_actions(int game_matrix[ROWS][COLUMNS],int player){
    struct MSet* actions = new_mset();
    for(int i=0;i<ROWS;i++){
        for(int j=0;j<COLUMNS;j++){
            if(game_matrix[i][j] == player){
                struct Move* move = new_move(i,j);
                printf("\navaible actions : ");
                struct MSet* neigbors =  point_neighbors(game_matrix,move,player);              
                neigbors->print(neigbors);
             
            }
        }
    }
    return actions;
};
void perform_move(struct Reversi *self,struct Move* move){
    self->game_matrix[move->x][move->y] = self->player;

}
bool isgame_over(struct Reversi *self){
    int number_of_cells = ROWS*COLUMNS;
    int coverd_cells = self->score_b + self->score_w;
    if(coverd_cells == number_of_cells){
        return false;
    }else if (self->score_b == 0 || self->score_w == 0)
    {
         return false;
    }
    return true;

}
void next_player(struct Reversi *self){
    self->player = (self->player == B)? W:B;
}
void count_score(struct Reversi *self){
    int score_w = 0;
    int score_b = 0;
    for(int i=0;i<ROWS;i++){
        for(int j=0;j<COLUMNS;j++){
            if(self->game_matrix[i][j] == B){
                score_b++;
            }else if (self->game_matrix[i][j] == W)
            {
                score_w++;
            }
            
        }
    }
    self->score_w = score_w;
    self->score_b = score_b;
}
void print_game(struct Reversi *self){
    
    
    int possible_moves[ROWS * COLUMNS][2];
    int num_moves;
    struct MSet* avaible_actions =  find_possible_moves(self->game_matrix, self->player, possible_moves, &num_moves);
    struct Move move;
    printf("\nW : White player");
    printf("     B : Black player");
    printf("\nP : Possible Moves");
    printf("     # : remaining cells");
    printf("\nW : %d\nB : %d",self->score_w,self->score_b);
    avaible_actions->print(avaible_actions);
    printf("Possible moves for player %d:\n", B);
    for (int i = 0; i < num_moves; i++) {
        printf("Move at: (%d, %d)\n", possible_moves[i][0], possible_moves[i][1]);
    }
    printf("\n\n");
    printf("    ");  
    for(int i = 0;i<COLUMNS;i++){
        printf("%d ",i);
    }
    for(int i=0;i<ROWS;i++){
        printf("\n %d  ",i);
    for(int j=0;j<COLUMNS;j++){
        move.x = i;move.y=j;
        int value ;
        if(avaible_actions->exists(avaible_actions,&move)){
            value = P;
        }else{
             value = self->game_matrix[i][j];
        }
         
        switch (value)
        {
        case W:
            printf("W ");
            break;
        case B:
            printf("B ");
            break;
        case P:
            printf("P ");
            break;
        default:
            printf("# ");
            break;
        }
    }

    }

}
bool is_valid_move(int board[ROWS][COLUMNS], int row, int col, int player) {
    if (board[row][col] != 0) {
        return false; // The cell is not empty
    }

    int directions[8][2] = {
        {-1, -1}, {-1, 0}, {-1, 1},
        {0, -1},          {0, 1},
        {1, -1}, {1, 0}, {1, 1}
    };

    int opponent = (player == W) ? B : W;

    for (int d = 0; d < 8; d++) {
        int dr = directions[d][0];
        int dc = directions[d][1];
        int r = row + dr;
        int c = col + dc;
        bool found_opponent = false;

        while (r >= 0 && r < ROWS && c >= 0 && c < COLUMNS) {
            if (board[r][c] == opponent) {
                found_opponent = true;
            } else if (board[r][c] == player && found_opponent) {
                return true; // Valid move if we found the player's disk after opponent's disks
            } else {
                break;
            }

            r += dr;
            c += dc;
        }
    }

    return false;
}

struct MSet* find_possible_moves(int board[ROWS][COLUMNS], int player, int possible_moves[ROWS * COLUMNS][2], int* num_moves) {
    *num_moves = 0;
    struct MSet* possible_actions = new_mset();
    for (int row = 0; row < ROWS; row++) {
        for (int col = 0; col < COLUMNS; col++) {
            if (is_valid_move(board, row, col, player)) {
                possible_moves[*num_moves][0] = row;
                possible_moves[*num_moves][1] = col;
                possible_actions->append(possible_actions,new_move(row,col));
                (*num_moves)++;

            
            }
        }
    }
    return possible_actions;
}

